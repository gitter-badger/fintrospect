<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Fintrospect by daviddenton</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Fintrospect</h1>
      <h2 class="project-tagline"></h2>
      <a href="https://github.com/daviddenton/fintrospect" class="btn">View on GitHub</a>
      <a href="https://github.com/daviddenton/fintrospect/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/daviddenton/fintrospect/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="fintrospect" class="anchor" href="#fintrospect" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fintrospect</h1>

<p><a href="https://travis-ci.org/daviddenton/fintrospect" target="_top"><img src="https://travis-ci.org/daviddenton/fintrospect.svg?branch=master"></a>
<a href="https://coveralls.io/github/daviddenton/fintrospect?branch=master" target="_top"><img src="https://coveralls.io/repos/daviddenton/fintrospect/badge.svg?branch=master"></a>
<a href="https://bintray.com/daviddenton/maven/fintrospect/_latestVersion" target="_top"><img src="https://api.bintray.com/packages/daviddenton/maven/fintrospect/images/download.svg"></a>
<a href="https://bintray.com/daviddenton/maven/fintrospect/view?source=watch" target="_top"><img src="https://www.bintray.com/docs/images/bintray_badge_color.png"></a></p>

<p>Fintrospect is a bolt-on HTTP routing library for use with the <a href="http://twitter.github.io/finagle/" target="_top">Finagle</a>  RPC framework from Twitter. It was developed out of a desire to provide a pleasant API for describing HTTP request routing in combination with statically-typed documentation which could be verified at compile time and auto-generated at runtime (and thus avoiding the stale documentation risk that exists with manually written docs).</p>

<p>Using this library, you can:</p>

<ul>
<li>Define individual HTTP routes and compose them into sensible context-based modules.</li>
<li>Declare both required and optional parameters to be used in the following locations: <code>Path/Header/Query/Form/Body</code>. Retrieval of the parameters is simple and type-safe (<code>[T]</code> for required, <code>Option[T]</code> for optional). Custom datatypes
for parameters are supported. Also support for typesafe conversions of custom types.</li>
<li>Automatically generate documentation in a variety of formats (e.g. <a href="http://swagger.io/" target="_top">Swagger</a> v1.1 and v2.0). Pluggable architecture for adding your own format renderers (e.g other JSON, XML).</li>
<li>Endpoints automatically verify the presence and validity of both optional and required parameters. If any parameters are missing or invalid, a <code>BAD_REQUEST</code> response is generated - meaning that no extra validation code is required for these parameters in your controller code.</li>
<li>The library provide identification HTTP headers for dynamic-path based endpoints, removing all dynamic path elements. This allows, for example, calls to particular endpoints to be grouped for metric purposes. e.g. <code>/search/author/rowling -&gt; /search/author/{name}</code>.</li>
<li>Define HTTP Client endpoints APIs which reuse the same syntax and parameter bindings as the server-side, which means that you can use the same route specification to define both sides of the transport boundary. This allows, for example,
the HTTP API of a downstream servers (for a fake) to be created with no effort, and exactly matching the client side. These endpoints are also exposed as simple functions.</li>
<li>A set of HTTP Response builders with pluggable extension points for custom formats; currently supported are:

<ul>
<li>Argo JSON (Java)</li>
<li>Argonaut JSON (v6.0.X compatible) (v10.1.X+)</li>
<li>Json4s (v3.2.X+ compatible) Native &amp; Jackson (v9+)</li>
<li>Play JSON (v2.4.X compatible) (v10.2.X+)</li>
<li>Spray JSON (v9+)</li>
<li>Scala native XML</li>
</ul>
</li>
</ul>

<h3>
<a id="get-it" class="anchor" href="#get-it" aria-hidden="true"><span class="octicon octicon-link"></span></a>Get it</h3>

<p>Add the following lines to <code>build.sbt</code>. Note that this library doesn't depend on a particular version of Finagle,
and it has built against the version below:</p>

<div class="highlight highlight-source-scala"><pre>resolvers <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>JCenter<span class="pl-pds">"</span></span> at <span class="pl-s"><span class="pl-pds">"</span>https://jcenter.bintray.com<span class="pl-pds">"</span></span>
libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>com.twitter<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>finagle-http<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>6.30.0<span class="pl-pds">"</span></span>
libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>io.github.daviddenton<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>fintrospect<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>X.X.X<span class="pl-pds">"</span></span></pre></div>

<p>Additionally, to activate any message formats other than Argo JSON and native XML you'll need to import the relevant libraries (e.g. Json4S native/jackson), since only the bindings are included in the Fintrospect JAR.</p>

<h3>
<a id="see-it" class="anchor" href="#see-it" aria-hidden="true"><span class="octicon octicon-link"></span></a>See it</h3>

<p>See the <a href="https://github.com/daviddenton/fintrospect/tree/master/src/test/scala/examples" target="_top">example code</a>.</p>

<h3>
<a id="learn-it" class="anchor" href="#learn-it" aria-hidden="true"><span class="octicon octicon-link"></span></a>Learn it</h3>

<h4>
<a id="server-side" class="anchor" href="#server-side" aria-hidden="true"><span class="octicon octicon-link"></span></a>Server-side</h4>

<p>Adding Fintrospect routes to a Finagle HTTP server is simple. For this example, we'll imagine a Library application (see the example above for the full code) which will be rendering Swagger v2 documentation.</p>

<h5>
<a id="define-a-module-to-live-at-httphost8080library" class="anchor" href="#define-a-module-to-live-at-httphost8080library" aria-hidden="true"><span class="octicon octicon-link"></span></a>Define a module to live at <code>http://{host}:8080/library</code>
</h5>

<p>This module will have a single endpoint <code>search</code>:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">val</span> <span class="pl-en">apiInfo</span> <span class="pl-k">=</span> <span class="pl-en">ApiInfo</span>(<span class="pl-s"><span class="pl-pds">"</span>Library Example<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>1.0<span class="pl-pds">"</span></span>, <span class="pl-en">Option</span>(<span class="pl-s"><span class="pl-pds">"</span>Simple description<span class="pl-pds">"</span></span>))
<span class="pl-k">val</span> <span class="pl-en">renderer</span> <span class="pl-k">=</span> <span class="pl-en">Swagger2dot0Json</span>(apiInfo) <span class="pl-c">// choose your renderer implementation</span>
<span class="pl-k">val</span> <span class="pl-en">libraryModule</span> <span class="pl-k">=</span> <span class="pl-en">FintrospectModule</span>(<span class="pl-en">Root</span> <span class="pl-k">/</span> <span class="pl-s"><span class="pl-pds">"</span>library<span class="pl-pds">"</span></span>, renderer)
    .withRoute(<span class="pl-k">new</span> <span class="pl-en">BookSearch</span>(<span class="pl-k">new</span> <span class="pl-en">BookRepo</span>()).route)
<span class="pl-k">val</span> <span class="pl-en">service</span> <span class="pl-k">=</span> <span class="pl-en">FintrospectModule</span>.toService(libraryModule)
<span class="pl-en">Http</span>.serve(<span class="pl-s"><span class="pl-pds">"</span>:8080<span class="pl-pds">"</span></span>, <span class="pl-k">new</span> <span class="pl-en">HttpFilter</span>(<span class="pl-en">Cors</span>.<span class="pl-en">UnsafePermissivePolicy</span>).andThen(service)) <span class="pl-c">// remember to make your own Cors Policy for prod!</span></pre></div>

<h5>
<a id="define-the-endpoint" class="anchor" href="#define-the-endpoint" aria-hidden="true"><span class="octicon octicon-link"></span></a>Define the endpoint</h5>

<p>This example is quite contrived (and almost all the code is optional) but shows the kind of thing that can be done. Note the use of the example response object, which will be broken down to provide the JSON model for the Swagger documentation.</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">class</span> <span class="pl-en">BookSearch</span>(<span class="pl-v">books</span>: <span class="pl-en">Books</span>) {
  <span class="pl-k">private</span> <span class="pl-k">val</span> <span class="pl-en">maxPages</span> <span class="pl-k">=</span> <span class="pl-en">Query</span>.optional.int(<span class="pl-s"><span class="pl-pds">"</span>maxPages<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>max number of pages in book<span class="pl-pds">"</span></span>)
  <span class="pl-k">private</span> <span class="pl-k">val</span> <span class="pl-en">minPages</span> <span class="pl-k">=</span> <span class="pl-en">FormField</span>.optional.int(<span class="pl-s"><span class="pl-pds">"</span>minPages<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>min number of pages in book<span class="pl-pds">"</span></span>)
  <span class="pl-k">private</span> <span class="pl-k">val</span> <span class="pl-en">titleTerm</span> <span class="pl-k">=</span> <span class="pl-en">FormField</span>.required.string(<span class="pl-s"><span class="pl-pds">"</span>term<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>the part of the title to look for<span class="pl-pds">"</span></span>)
  <span class="pl-k">private</span> <span class="pl-k">val</span> <span class="pl-en">form</span> <span class="pl-k">=</span> <span class="pl-en">Body</span>.form(minPages, titleTerm)

  <span class="pl-k">private</span> <span class="pl-k">def</span> <span class="pl-en">search</span>() <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Service</span>[<span class="pl-en">Request</span>, <span class="pl-en">Response</span>] {
    <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">apply</span>(<span class="pl-v">request</span>: <span class="pl-en">Request</span>)<span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-en">Response</span>] <span class="pl-k">=</span> {
      <span class="pl-k">val</span> <span class="pl-en">requestForm</span> <span class="pl-k">=</span> form.from(request)
      <span class="pl-en">Ok</span>(array(books.search(minPages.from(requestForm).getOrElse(<span class="pl-en">MIN_VALUE</span>),
        maxPages.from(request).getOrElse(<span class="pl-en">MAX_VALUE</span>),
        titleTerm.from(requestForm)).map(_.toJson)))
    }
  }

  <span class="pl-k">val</span> <span class="pl-en">route</span> <span class="pl-k">=</span> <span class="pl-en">RouteSpec</span>(<span class="pl-s"><span class="pl-pds">"</span>search for books<span class="pl-pds">"</span></span>)
    .taking(maxPages)
    .body(form)
    .returning(<span class="pl-en">Ok</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>we found your book<span class="pl-pds">"</span></span>, array(<span class="pl-en">Book</span>(<span class="pl-s"><span class="pl-pds">"</span>a book<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>authorName<span class="pl-pds">"</span></span>, <span class="pl-c1">99</span>).toJson))
    .returning(<span class="pl-en">BadRequest</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>invalid request<span class="pl-pds">"</span></span>)
    .producing(<span class="pl-en">APPLICATION_JSON</span>)
    .at(<span class="pl-en">Post</span>) <span class="pl-k">/</span> <span class="pl-s"><span class="pl-pds">"</span>search<span class="pl-pds">"</span></span> bindTo search
}</pre></div>

<h5>
<a id="view-the-generated-documentation" class="anchor" href="#view-the-generated-documentation" aria-hidden="true"><span class="octicon octicon-link"></span></a>View the generated documentation</h5>

<p>The auto-generated documentation lives at the root of the module, so point the Swagger UI at <code>http://{host}:8080/library</code> to see it.</p>

<h4>
<a id="client-side" class="anchor" href="#client-side" aria-hidden="true"><span class="octicon octicon-link"></span></a>Client-side</h4>

<p>Declare the fields to be sent to the client service and then bind them to a remote service. This produces a simple function, which can then be called with the bindings for each parameter.</p>

<div class="highlight highlight-source-scala"><pre>  <span class="pl-k">val</span> <span class="pl-en">httpClient</span> <span class="pl-k">=</span> <span class="pl-en">Http</span>.newService(<span class="pl-s"><span class="pl-pds">"</span>localhost:10000<span class="pl-pds">"</span></span>)

  <span class="pl-k">val</span> <span class="pl-en">theUser</span> <span class="pl-k">=</span> <span class="pl-en">Path</span>.string(<span class="pl-s"><span class="pl-pds">"</span>user<span class="pl-pds">"</span></span>)
  <span class="pl-k">val</span> <span class="pl-en">gender</span> <span class="pl-k">=</span> <span class="pl-en">Header</span>.required.string(<span class="pl-s"><span class="pl-pds">"</span>gender<span class="pl-pds">"</span></span>)
  <span class="pl-k">val</span> <span class="pl-en">theDate</span> <span class="pl-k">=</span> <span class="pl-en">FormField</span>.required.localDate(<span class="pl-s"><span class="pl-pds">"</span>date<span class="pl-pds">"</span></span>)
  <span class="pl-k">val</span> <span class="pl-en">body</span> <span class="pl-k">=</span> <span class="pl-en">Body</span>.form(theDate)

  <span class="pl-k">val</span> <span class="pl-en">formClient</span> <span class="pl-k">=</span> <span class="pl-en">RouteSpec</span>()
    .taking(gender)
    .body(body)
    .at(<span class="pl-en">Get</span>) <span class="pl-k">/</span> <span class="pl-s"><span class="pl-pds">"</span>firstSection<span class="pl-pds">"</span></span> <span class="pl-k">/</span> theUser bindToClient httpClient

  <span class="pl-k">val</span> <span class="pl-en">theCall</span> <span class="pl-k">=</span> formClient(gender <span class="pl-k">--</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>female<span class="pl-pds">"</span></span>, body <span class="pl-k">--</span><span class="pl-k">&gt;</span> <span class="pl-en">Form</span>(theDate <span class="pl-k">--</span><span class="pl-k">&gt;</span> <span class="pl-en">LocalDate</span>.of(<span class="pl-c1">2015</span>, <span class="pl-c1">1</span>, <span class="pl-c1">1</span>)), theUser <span class="pl-k">--</span><span class="pl-k">&gt;</span> <span class="pl-en">System</span>.getenv(<span class="pl-s"><span class="pl-pds">"</span>USER<span class="pl-pds">"</span></span>))

  println(<span class="pl-en">Await</span>.result(theCall))</pre></div>

<h5>
<a id="test-it" class="anchor" href="#test-it" aria-hidden="true"><span class="octicon octicon-link"></span></a>Test it</h5>

<p>Fintrospect ships with a testing trait <code>TestingFintrospectRoute</code>, which you can mix into your tests in order to validate your declared server-side routes.</p>

<h3>
<a id="upgrading" class="anchor" href="#upgrading" aria-hidden="true"><span class="octicon octicon-link"></span></a>Upgrading?</h3>

<p>See the <a href="https://github.com/daviddenton/fintrospect/blob/master/RELEASE.md" target="_top">Roadmap</a>.</p>

<h3>
<a id="contributions" class="anchor" href="#contributions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Contributions</h3>

<p>If there are any message format libraries bindings that you'd like to see included, then please feel free to suggest them or provide a PR. For JSON formats, this
is particularly easy to implement - just provide an implementation of <code>JsonLibrary</code> by following the <code>Argo</code> example in the source.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/daviddenton/fintrospect">Fintrospect</a> is maintained by <a href="https://github.com/daviddenton">daviddenton</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

            <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-69281315-3");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
